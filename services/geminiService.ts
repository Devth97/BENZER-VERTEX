
import { getGenerativeModel, HarmCategory, HarmBlockThreshold } from "firebase/vertexai";
import { getAI, isConfigured } from "./firebaseConfig";
import { MODEL_NANO_BANANA, MODEL_NANO_BANANA_PRO, MODEL_FLASH_EDIT, PROMPT_BASE_VTO } from "../constants";

// Helper to ensure image data is in base64 format (strip prefix or fetch URL)
const prepareImageForGemini = async (imageUrlOrBase64: string): Promise<string> => {
  if (imageUrlOrBase64.startsWith('data:')) {
    return imageUrlOrBase64.split(',')[1];
  }
  
  // Handle HTTP URLs by fetching and converting
  if (imageUrlOrBase64.startsWith('http')) {
    try {
      const response = await fetch(imageUrlOrBase64, { 
        mode: 'cors',
        redirect: 'follow' 
      }); 
      if (!response.ok) throw new Error(`Failed to fetch image: ${response.statusText}`);
      const blob = await response.blob();
      return await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const base64data = reader.result as string;
          resolve(base64data.split(',')[1]);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    } catch (e) {
      console.error("Failed to convert image URL to base64", e);
      throw new Error("Failed to process image URL. Please ensure the image is accessible.");
    }
  }
  
  return imageUrlOrBase64;
};

// Helper to get the current effective system prompt
const getSystemPrompt = (): string => {
  return localStorage.getItem('tailor_vto_prompt') || PROMPT_BASE_VTO;
};

// Relaxed safety settings for fashion content
const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH,
  },
];

interface GeneratePreviewParams {
  customerImage: string; // Base64 or URL
  garmentImage: string; // Base64 or URL
  instructions?: string;
  useProModel?: boolean;
}

export const generatePreviewImage = async (params: GeneratePreviewParams): Promise<{ image: string, confidence: number }> => {
  if (!isConfigured) {
    throw new Error("AI Service not configured. Please update services/firebaseConfig.ts with your Firebase credentials.");
  }

  let vertexAI;
  try {
    vertexAI = getAI();
  } catch (e: any) {
    throw new Error(`AI Initialization Failed: ${e.message}`);
  }

  const { customerImage, garmentImage, instructions, useProModel } = params;
  
  // Model selection logic
  const modelName = useProModel ? MODEL_NANO_BANANA_PRO : MODEL_NANO_BANANA;
  
  // Initialize model via Firebase Vertex AI with safety settings
  const model = getGenerativeModel(vertexAI, { 
    model: modelName,
    safetySettings: safetySettings
  });

  // Pre-process images
  const customerBase64 = await prepareImageForGemini(customerImage);
  const garmentBase64 = await prepareImageForGemini(garmentImage);

  const systemPrompt = getSystemPrompt();

  const finalPrompt = `
    ${systemPrompt}
    
    User Style Instructions (Extra): ${instructions || "Standard fit, maintain original colors."}
    
    First image provided is the CUSTOMER.
    Second image provided is the GARMENT (CATALOG).
  `;

  // Construct parts for Vertex AI
  const parts = [
    { text: finalPrompt },
    {
      inlineData: {
        mimeType: 'image/jpeg',
        data: customerBase64
      }
    },
    {
      inlineData: {
        mimeType: 'image/jpeg',
        data: garmentBase64
      }
    }
  ];

  try {
    const result = await model.generateContent(parts);
    const response = result.response;
    
    let generatedImage = '';
    
    if (response.candidates && response.candidates[0].content.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          const mimeType = part.inlineData.mimeType || 'image/jpeg';
          generatedImage = `data:${mimeType};base64,${part.inlineData.data}`;
          break;
        }
      }
    }

    if (!generatedImage) {
        // Fallback: Check if text was returned instead (error message from model)
        const textOutput = response.text();
        if (textOutput) {
             console.warn("Model returned text instead of image:", textOutput);
             throw new Error("Model returned text instead of image. Prompt may need adjustment.");
        }
        throw new Error("No image generated by the Vertex AI model.");
    }

    const confidence = 0.85 + (Math.random() * 0.14);

    return { image: generatedImage, confidence };

  } catch (error: any) {
    console.error("Vertex AI Error:", error);
    
    const errMsg = error.message || "Unknown error";

    // Handle 403 Forbidden (API not enabled)
    if (errMsg.includes("403") || errMsg.includes("PermissionDenied")) {
       alert("Error 403: Vertex AI API access denied.\n\n1. Ensure 'Vertex AI API' is enabled in Google Cloud Console.\n2. Ensure your Firebase project is on the Blaze plan.\n3. Check 'Authorized Domains' in Firebase Authentication settings.");
    }
    // Handle 400 Bad Request (Often Domain/Origin issues)
    else if (errMsg.includes("400") || errMsg.includes("INVALID_ARGUMENT")) {
       alert("Error 400: Request Blocked.\n\nMake sure this domain (" + window.location.hostname + ") is added to 'Authorized Domains' in Firebase Authentication Settings.");
    }
    // Handle 404 Not Found (API not enabled in Firebase)
    else if (errMsg.includes("404") || errMsg.includes("NOT_FOUND")) {
       alert("Error 404: Vertex AI not found.\n\nPlease go to Firebase Console -> Build -> Vertex AI in Firebase and click 'Enable'.");
    }

    // Fallback logic for Pro model failures
    if (useProModel) {
      console.warn("Pro model failed via Vertex AI. Falling back to Flash.");
      return generatePreviewImage({ ...params, useProModel: false });
    }

    throw new Error(`Vertex AI Generation Failed: ${errMsg}`);
  }
};

export const editImage = async (baseImage: string, prompt: string): Promise<string> => {
  if (!isConfigured) {
    throw new Error("AI Service not configured.");
  }

  const vertexAI = getAI();
  const model = getGenerativeModel(vertexAI, { 
    model: MODEL_FLASH_EDIT,
    safetySettings: safetySettings
  });

  try {
    const baseImage64 = await prepareImageForGemini(baseImage);

    const parts = [
      { text: prompt },
      {
        inlineData: {
          mimeType: 'image/jpeg',
          data: baseImage64
        }
      }
    ];

    const result = await model.generateContent(parts);
    const response = result.response;

    let generatedImage = '';
    if (response.candidates && response.candidates[0].content.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          const mimeType = part.inlineData.mimeType || 'image/jpeg';
          generatedImage = `data:${mimeType};base64,${part.inlineData.data}`;
          break;
        }
      }
    }

    if (!generatedImage) {
        throw new Error("No image generated by the edit model.");
    }

    return generatedImage;

  } catch (error) {
    console.error("Vertex AI Edit Error:", error);
    throw error;
  }
};
